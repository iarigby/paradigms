---
nav_order: 2
title: მეორე სემინარი (ია)
parent: ია
grand_parent: სემინარები
---

ამ სემინარზე განხილული მასალა არ შედის გამოცდაში, მაგრამ რამდენიმე მიზეზის გამო მნიშვნელოვანია რომ პროგრამის შექმნის პროცესი კარგად გესმოდეთ. 


# კომპილაციის პროცესი
კოდისგან პროგრამის შექმნა ორ ნაწილად არის დაყოფილი, რომ დიდ პროექტში ერთი ფაილის შექმნისას დანარჩენი ასეულობით თავიდან არ გაანალიზდეს. 

```sh
gcc -c main.c
gcc -c module1.c
gcc -c module2.c
gcc -o prog main.o module1.o module2.o 
```

ტერმინები: დეკლარაცია, დეფინიცია, header file, source file

### compile
- სინტაქსის შემოწმება
- სხვა ფაილები არ არის საჭირო, მხოლოდ header ფაილი რომ შეამოწმოს რომ ფუნქცია არსებობს, სწორად იყენებ და ა.შ

შეცდომა მოხდება, თუ 
- არის სინტაქსური შეცდომა
- რამე ფუნქციას იყენებ, რომლის დეკლარაციაც ვერ მოიძებნა

output: object file

### link
აქ უბრალოდ header fileების ფუნქციებს მიმართავს მათ ლოკაციასთან, აკავშირებს ერთმანეთს და აერთიანებს ერთ პროგრამაში. 

შეცდომა მოხდება
- თუ რომელიმე დეფინიცია ვერ იპოვა.
- ვერ იპოვა main ფუნქცია

output: program

კომპილაციის პროცესი და gcc-ის მთავარი flag-ები უფრო დაწვრილებით ახსნილია ჰენდაუთში [gcc reference](/content/handouts/compilation_process.pdf)

# make utility
ამდენ ბრძანებას ყოველ ჯერზე ხელით ვერ შევიყვანთ. ერთი ალტერნატივაა, რომ დავწეროთ სკრიპტი, რომელსაც არგუმენტს რომ მივცემთ იმ კონკრეტულს შეასრულებს. ამ სკრიპტს უნდა შეეძლოს
- compile, link, run 
- ამ სამის დამოკიდებულების კონტროლი. თუ შევიყვანთ ბრძანებას run, მაშინ შეცვლილი თუა ფაილი, თავისით უნდა მიხვდეს. ასევე, თუ კომპილაციაზე პრობლემა იყო, ლინკინგი არ უნდა მოხდეს, თორემ ძველ object file-ს გამოიყენებს და დავიბნევით.

ადრე ასეც იყო და ხელით წერდნენ ხოლმე ყველა პროექტისთვის დასაკომპაილებელ სკრტიპს. შემდეგ 

[make reference](/content/handouts/make_utility.pdf)


